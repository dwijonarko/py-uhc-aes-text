# -*- coding: utf-8 -*-
"""Copy of Hill-AESCBC Cipher_Teks_update (works).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XQ8kB1rEB1PSKwuskwgjq2HtfmwUrWWS
"""

#!pip install pycryptodome
#!pip install matplotlib
import base64
import os
import numpy as np
import time
import math
import string
import matplotlib.pyplot as plt
from scipy.stats import pearsonr
from functools import reduce
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from collections import Counter


def create_original_text(file_path):
    original = "In the realm of communication, symbols play a pivotal role in conveying complex ideas efficiently. Let's explore a diverse collection of symbols: starting with the alphabet, we have A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, and Z, which are foundational to the English language. Punctuation marks, such as the period (.), comma (,), question mark (?), exclamation mark (!), colon (:), semicolon (;), hyphen (-), and dash (—), help structure sentences and clarify meaning.Moving to mathematical symbols, we encounter the plus (+), minus (-), multiplication (×), division (÷), equal (=), not equal (≠), less than (<), greater than (>), less than or equal to (≤), and greater than or equal to (≥). Parentheses (()), brackets ([]), braces ({}), and the vertical bar (|) are used to group and separate elements in equations. The integral (∫) and summation (Σ) symbols are crucial in calculus, while the infinity symbol (∞) represents an unbounded value.Scientific symbols include elements from the periodic table, such as hydrogen (H), oxygen (O), and carbon (C). In physics, we have symbols like the speed of light (c), Planck's constant (h), and the gravitational constant (G). In chemistry, the delta symbol (Δ) denotes a change, and the sigma symbol (σ) represents standard deviation in statistics.Currency symbols, such as the dollar sign ($), euro (€), pound sterling (£), yen (¥), and rupee (₹), indicate different monetary units. Each symbol carries significant economic meaning and is recognized globally. Other financial symbols include the percent sign (%), which indicates a percentage, and the per mille sign (‰), representing parts per thousand.Musical notation introduces symbols like the treble clef (𝄞), bass clef (𝄢), sharp (♯), flat (♭), natural (♮), quarter note (♩), half note (𝅗𝅥), and whole note (𝅝). These symbols allow musicians to read and perform compositions accurately.Astrological symbols include signs of the zodiac, such as Aries (♈), Taurus (♉), Gemini (♊), Cancer (♋), Leo (♌), Virgo (♍), Libra (♎), Scorpio (♏), Sagittarius (♐), Capricorn (♑), Aquarius (♒), and Pisces (♓). Each symbol represents a constellation and is associated with specific traits and time periods.In the digital age, we encounter an array of symbols used in computing and technology. The at symbol (@) is crucial for email addresses, while the hashtag (#) is prevalent on social media. The ampersand (&) is used in programming languages and business names. Additionally, the backslash () and forward slash (/) are essential in file paths and URLs.Emoji symbols have become ubiquitous in modern communication, adding emotional nuance to text. Examples include the smiley face (😊), heart (❤️), thumbs up (👍), and the crying face (😢). Emojis transcend language barriers, offering a universal means of expression.Symbols of religion and spirituality are deeply ingrained in cultures worldwide. The Christian cross (✝) represents Christianity, the crescent and star (☪) symbolize Islam, the Star of David (✡) denotes Judaism, the Om symbol (ॐ) is significant in Hinduism, and the dharmachakra (☸) is associated with Buddhism.Traffic signs and safety symbols ensure order and convey important information in public spaces. The stop sign (🛑), yield sign (🛑), pedestrian crossing (🚸), and no entry sign (🚫) are instantly recognizable and crucial for safety.Lastly, we have symbols that represent abstract concepts and ideas. The heart symbol (♥) signifies love, the peace symbol (☮) represents harmony, and the yin-yang (☯) embodies balance. The recycle symbol (♻) promotes environmental consciousness, and the infinity symbol (∞) suggests boundlessness.In summary, symbols are integral to human communication, transcending linguistic boundaries and cultural differences. From alphabets and punctuation to mathematical, scientific, musical, astrological, technological, and religious symbols, each plays a unique role in conveying meaning, facilitating understanding, and enriching our interaction with the world."
    with open(file_path, "w") as file:
        file.write(original)


def text_to_numeric(text):
    return np.array([ord(char) for char in text])


def calculate_correlation(original_text, encrypted_text):
    # Konversi teks ke dalam bentuk numerik
    original_numeric = text_to_numeric(original_text)
    encrypted_numeric = text_to_numeric(encrypted_text)

    # Pastikan panjang teks sama
    min_length = min(len(original_numeric), len(encrypted_numeric))
    original_numeric = original_numeric[:min_length]
    encrypted_numeric = encrypted_numeric[:min_length]

    # Hitung korelasi Pearson
    correlation, _ = pearsonr(original_numeric, encrypted_numeric)

    return correlation


def plot_letter_histogram(file_path):
    with open(file_path, "r") as file:
        text = file.read().lower()  # Membaca isi file dan mengubah ke huruf kecil

    # Filter hanya huruf alfabet
    letters_only = "".join(filter(lambda x: x in string.ascii_lowercase, text))

    # Hitung frekuensi setiap huruf
    letter_count = Counter(letters_only)

    # Siapkan data untuk histogram
    letters = sorted(letter_count.keys())
    frequencies = [letter_count[letter] for letter in letters]

    # Plot histogram
    plt.bar(letters, frequencies)
    plt.xlabel("Letters")
    plt.ylabel("Frequency")
    plt.title("Letter Frequency Histogram")
    plt.show()


def get_file_size(file_path):
    # Menggunakan os.path.getsize untuk mendapatkan ukuran file dalam byte
    size_in_bytes = os.path.getsize(file_path)
    return size_in_bytes


# analisis Entropy
def calculate_entropy(data):
    # Hitung frekuensi setiap karakter
    freq = Counter(data)
    total_chars = len(data)

    # Hitung entropi
    entropy = -sum(
        (count / total_chars) * math.log2(count / total_chars)
        for count in freq.values()
    )
    return entropy


# metode 2: AES
# fungsi untuk padding data
def pad(s):
    return s + b"\0" * (AES.block_size - len(s) % AES.block_size)


# fungsi untuk enkripsi data
def encrypt(message, key, iv):
    message = pad(message)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return iv + cipher.encrypt(message)


# fungsi untuk dekripsi data
def decrypt(ciphertext, key):
    iv = ciphertext[:16]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext[16:])
    return plaintext.rstrip(b"\0")


# metode 1: UHC
def factors(n):
    return set(
        reduce(
            list.__add__, ([i, n // i] for i in range(1, int(n**0.5) + 1) if n % i == 0)
        )
    )


# OBE
def r_ij(m, baris_i, baris_j, r):
    return m[baris_i] + r * m[baris_j]


# barisan logistic map
def log(x0, banyak):
    x = x0
    for i in range(1000):
        x = 3.9 * x - np.floor(3.9 * x)  # 3.9 bisa diganti bil. pada [3.7, 4]

    barisan = np.zeros(banyak, dtype=np.uint16)
    for i in range(banyak):
        x = 3.9 * x - np.floor(3.9 * x)  # 3.9 bisa diganti bil. pada [3.7, 4]
        barisan[i] = x * 1000 % 55000
    return barisan


# matriks kunci
def kunci(n, x0):
    # matriks segitiga atas
    banyak = int(n * (n - 1) / 2)
    barisan = log(x0, banyak + n - 1)
    msa = np.eye(n)
    indeks = 0
    for i in range(n):
        for j in range(i + 1, n):
            msa[i, j] = barisan[indeks]
            indeks += 1
    for baris_i in range(1, n):
        msa[baris_i] = r_ij(msa, baris_i, 0, barisan[indeks]) % 55000
        indeks += 1
    augmented = np.zeros((n, 2 * n))
    augmented[:, :n] = msa
    augmented[:, n:] = np.eye(n)
    # OBE untuk dapatkan invers
    # mengenolkan segitiga bawah
    for kolom in range(n):
        for baris in range(kolom + 1, n):
            augmented[baris] = (
                r_ij(augmented, baris, kolom, -augmented[baris, kolom]) % 55000
            )
    # mengenolkan segitiga atas
    for kolom in range(1, n):
        for baris in range(kolom):
            augmented[baris] = (
                r_ij(augmented, baris, kolom, -augmented[baris, kolom]) % 55000
            )
    mbalik = augmented[:, n:]
    return msa, mbalik


# enkripsi UHC
def enkripsi(nama_plainteks):
    teks_asli = open(nama_plainteks, "r", encoding="utf-8")
    teks = teks_asli.read()
    n_teks = len(teks)
    if n_teks % 2 == 1:
        teks = teks + "."
    n_teks = len(teks)
    print(n_teks)
    print("Teks asli:", teks)
    # convert teks ke bilangan bulat
    mteks = [ord(i) for i in teks]
    np_teks = np.array(mteks)
    print(np_teks)
    f = factors(n_teks)
    faktor = list(f)
    print(faktor[1:])
    str_password1 = input(
        "Please choose one of the numbers in the set above as Password 1: "
    )
    password1 = int(str_password1)
    while password1 not in faktor:
        print("Your choice are {}".format(password1))
        print("Not in the given list.")
        print("-" * 50, "\nThe list of numbers are: ")
        print(faktor)
        password1 = input("Please choose again the right one: ")
    pw2 = input(
        "Enter Password 2 in the form of a number, maximum 14 digits (example: 22021985)\nPassword 2: "
    )
    password2 = float("0." + pw2 + "1")
    waktu_awal = time.time()
    # membuat matriks persegi sebagai kunci berukuran password1 x password1
    ukuran = password1
    x0 = password2
    kunciku, balikku = kunci(ukuran, x0)
    print(
        f"Using password1: {password1} and password2: {password2}, the unimodular matrix generated is:"
    )
    print(kunciku)
    print("=" * 20)
    print(f"maks = {np_teks.max()}")
    print(np_teks)
    np_teks_reshape = np_teks.reshape((ukuran, int(np_teks.size / ukuran)))
    print(f"len: {np_teks.shape}")
    print(f"len: {kunciku.shape}")
    print(f"len: {np_teks_reshape.shape}")

    np_kali = (kunciku @ np_teks_reshape) % 55000
    np_chiper = np_kali.reshape(n_teks).astype(np.uint64)
    petaku = np.transpose(np.array([np_teks, np_chiper]))
    chiper = open("enkripsi.txt", "w", encoding="utf-8")
    chiper.write("".join([chr(i) for i in np_chiper]))
    chiper.close()
    waktu_akhir = time.time()
    selama = waktu_akhir - waktu_awal
    print(f"waktu enkripsi UHC: {selama} detik")


# dekripsi UHC
def dekripsi(nama_chiperteks):
    nama_file = nama_chiperteks
    teks_asli = open(nama_file, "r", encoding="utf-8")
    teks = teks_asli.read()
    teks_asli.close()
    n_teks = len(teks)
    if n_teks % 2 == 1:
        teks = teks + "."
    n_teks = len(teks)
    # convert teks ke bilangan bulat
    mteks = [ord(i) for i in teks]
    np_teks = np.array(mteks)
    f = factors(n_teks)
    faktor = list(f)
    str_password1 = input("Please input password 1: ")
    password1 = int(str_password1)
    pw2 = input("Please input password 2: ")
    password2 = float("0." + pw2 + "1")
    waktu_awal = time.time()
    # membuat matriks persegi sebagai kunci berukuran password1 x password1
    ukuran = password1
    x0 = password2
    print(ukuran)
    print(x0)
    kunciku, balikku = kunci(ukuran, x0)
    print("=" * 20)
    print(np.dot(kunciku, balikku) % 55000)
    print("-" * 30)
    # print(np_teks)
    np_teks_reshape = np_teks.reshape((ukuran, int(np_teks.size / ukuran)))
    # print(np_teks_reshape)
    print(f"len: {np_teks.shape}")
    print(f"len: {kunciku.shape}")
    print(f"len: {np_teks_reshape.shape}")
    np_kali = (balikku @ np_teks_reshape) % 55000
    # print(np_kali)
    np_dechiper = np_kali.reshape(n_teks).astype(np.uint64)
    print(np_dechiper)
    chiper = open("dekripsi.txt", "w", encoding="utf-8")
    chiper.write("".join([chr(i) for i in np_dechiper]))
    chiper.close()
    selama = time.time() - waktu_awal
    print(f"waktu dekripsi UHC: {selama} detik")


################################################################################
# penggunaan
print("=" * 70)
print("Text Encryption Algorithm Trough Unimodular Matrix and Logistic Map")
print("-" * 70)
create_original_text("original.txt")
jawaban = input("Please select, you want to encrypt (e) or decrypt (d):")
if jawaban == "e" or jawaban == "E":
    print("-------------------------")
    print("You will encrypt a plaintext")
    print("-------------------------")
    # proses enkripsi UHC dimulai
    plainteks = "original.txt"
    waktu_awal = time.time()
    enkripsi(plainteks)  # outputnya ini nama filenya apa?
    # proses enkripsi AES dimulai
    with open("enkripsi.txt", "rb") as f:
        plaintext = f.read()
    key = os.urandom(16)  # menggunakan key 16 byte
    iv = os.urandom(16)  # menggunakan iv 16 byte

    kunci_aes = open("Kunci-AES.txt", "bw")
    kunci_aes.write(key)
    kunci_aes.close()
    waktu_awal = time.time()
    ciphertext = encrypt(plaintext, key, iv)
    base64_string = base64.b64encode(ciphertext)

    # tulis file hasil enkripsi
    with open("uhcAES_encrypted.txt", "wb") as f:
        f.write(base64_string)
    selama = time.time() - waktu_awal
    print(f"waktu enkripsi AES: {selama} detik")
    print(f"Nilai entropy : {calculate_entropy(ciphertext)} ")
    print(f"Ukuran file asli : {get_file_size(plainteks)} byte")
    print(f'Ukuran file enkripsi : {get_file_size("uhcAES_encrypted.txt")} byte')
    correlation = calculate_correlation("plaintext", "uhcAES_encrypted.txt")
    print(f"Nilai korelasi antara teks asli dan terenkripsi: {correlation}")
    plot_letter_histogram(plainteks)
    plot_letter_histogram("uhcAES_encrypted.txt")
else:
    print("*" * 80)
    print("You will decrypt a chipertext")
    print("-" * 50)
    # chiperteks = input('Masukkan nama file chiperteks beserta ekstensinya: ')
    # proses dekripsi AES
    waktu_awal = time.time()
    # baca file hasil enkripsi
    with open("uhcAES_encrypted.txt", "rb") as f:
        ciphertext = f.read()

    # decode 64
    decoded_bytes = base64.b64decode(ciphertext)

    # dekripsi isi file hasil enkripsi

    with open("Kunci-AES.txt", "rb") as f:
        key = f.read()
    plaintext = decrypt(decoded_bytes, key)
    with open("uhcAES_decrypted.txt", "wb") as f:
        f.write(plaintext)
    selama = time.time() - waktu_awal
    print(f"waktu dekripsi AES: {selama} detik")

    # proses dekripsi UHC dimulai
    dekripsi("uhcAES_decrypted.txt")

    # tulis file hasil dekripsi
    # with open("Final_decrypted.txt", "wb") as f:
    #   f.write(plaintext)
